# 文件工具



*Python*中的内建函数`open`是脚本用来在计算机底层系统下访问文件的主要工具。`open`函数被调用时将返回一个新的与外部文件相连的文件对象。这个文件对象有一些方法，可以与文件双向传输数据，并且能执行多种文件的相关操作。`open`函数还为底层文件系统提供了可移植接口。

回忆一下，可以对打开的对象运行`dir(obj)`来查看其属性、方法等；可以运行`help(obj)`获取通用帮助信息，还可以运行`help(obj.method)`获取`method`特定方法的帮助信息。



## *Python 3.X*中的文件对象类型

*Python 3.X*中的`str`字符串总是代表*Unicode*文本（*ASCII*或更广的字符集），而`bytes`和`bytearray`字符串代表原始二进制数据。

- 文本文件含有*Unicode*文本。在你的脚本中，文本文件内容始终是一个**`str`字符串——字符构成的序列**（准确地说是*Unicode*“代码点”）。在本章文本文件**默认执行换行符自动转换**，而且**自动将** ***Unicode*** **编码应用于文件内容**：它们在文件进行双向传输时依照一个给定或默认的编码名称，对原始二进制字节进行编码和解码。**编码对** ***ASCII*** **文本来说很简单**，但在其他情况下可能比较复杂。
- 二进制文件包含原始的8位字节。在你的脚本中，二进制文本文件的文件内容始终是**一个字节字符串， 通常是一个字节对象——小整数构成的序列**，支持**大多数** ***str*** **操作并尽量显示为** ***ASCII*** **字符**。二进制文件与其他文件进行双向传输的时候**不进行换行符转换和** ***Unicode*** **编码**。

在实践中，**文本文件用于所有真正的文本相关数据，而二进制文件则用于存储内容**。

从程序员的角度看，这两种文件类型是在通过传入`open`的模式字符串参数来区分的：参数中填上“b”（比如`rb`、`wb`等），将意味着文件包含二级制数据。在对编码新文件内容时，对文本使用普通字符串（如'spam'或`bytes.decode`），而对二进制使用字节字符串（如b'spam'或`str.encode`）。

由于文本模式要求文件内容能够按照某个*Unicode*编码方案的内容进行解码，所以你必须在二进制模式下将不可解码的内容读取为字节字符串（或者在`try`语句中捕获*Unicode*异常，然后整个跳过该文件）。这些文件可能包括真正的二进制文件以及使用非默认的未知编码的文本文件。



## 使用内建文件对象

### 输出文件

```python
>>> file = open('data.txt', 'w')				# 打开输出文件对象：创建
>>> file.write('1')								# 逐字写入字符串
1												# 返回所写入的字符或字节数目
>>> file.write('2')
1
>>> file.writelines(['3', '4'])					# 将列表里的所有字符串一次性写入
>>> file.writelines(['5', '6'])
>>> file.close()								# 在垃圾回收和退出时也会关闭文件
```

```shell
beacherhou@alone-Vostro-14-5401:/media/beacherhou/Coding/code_obsidian_知识库/Python编程_Markdown笔记/pp4e/system$ cat data.txt
123456
```

```python
open('file', 'w').write('Good night\n')			# 写入临时对象
open('file', 'r').read()						# 从临时对象中读取
```

- 因为以上两个表达式生成了一个临时文件对象，并且马上被使用，而且没有保存对对象的引用，所以在数据传输后，文件对象马上就被回收并在进程中自动关闭。在这种代码中通常没有必要去显示调用`close`方法

### 确保文件关闭：异常处理器和上下文管理器

当程序抛出异常，文件还未手动关闭时，首先要确认是否必须关闭——文件回收时会自动关闭，关闭最终会执行，即便发生异常。

如果必须关闭，那么又两种基本解决方法。

- `try ... finally ... `语句

```python
my_file = open(filename, 'w')

try:
    ...process my_file...
finally:
    my_file.close()
```

- `with ... `语句。这个语句依赖于文件对象的上下文管理器：无论发生什么异常行为，代码在进入和离开语句时都能自动运行。`with`语句也可指定多个（嵌套）上下文管理器。

```python
# 单个上下文管理器
with open(filename, 'w') as my_file:
    ...process my_file, auto-closed on statement exit...

# 多个上下文管理器：可用逗号隔开，或者嵌套
with open(file_name_1, 'w') as file_1, open(file_name_2, 'w') as file_2:
    ...statements...

with open(file_name_1, 'w') as file_1:
    with open(file_name_2, 'w') as file_2:
		...statements...
```

`with`仅应用于支持上下文管理协议的对象，而`try...finally`允许任意异常情况下的任意退出操作。

### 输入文件

```python
>>> file = open('data.txt')
>>> 
>>> file.read()
'123456'
>>> 
>>> file.seek(0)
0
>>> file.read(1)
'1'
>>> file.read(3)
'234'
>>> file.read(-1)
'56'
>>> 
>>> file.seek(0)
0
>>> file.readline()
'123456'
>>> 
>>> file.seek(0)
0
>>> file.readlines()
['123456']
```

- `file.seek(N)`：调用`seek`只是让我们下次的传输操作移动到偏移值为N的新位置，文件中所有的读取和写入操作都发生于当前位置。
- `file.read()`：返回一个字符串，它包含返回在文件中的所有字符。
- `file.read(N)`：返回一个字符串，它包含文件中接下来的N个字符（或字节）。
- `file.readline()`：读取下一个\\n之前的内容并返回一个行字符串。
- `file.readlines()`：读取整个文件并返回一个行字符串列表。

### 使用文件迭代器读取行

演示需要，修改了data.txt：

```shell
beacherhou@alone-Vostro-14-5401:/media/beacherhou/Coding/code_obsidian_知识库/Python编程_Markdown笔记/pp4e/system$ cat data.txt 
1
2
3
4
5
6
```

无需使用`readlines`，迭代器会自动读取行：

```python
>>> for line_str in open('data.txt'):
...     print(line_str, end='')
... 
1
2
3
4
5
6
```

- 你可以在这个循环本身把文件作为临时对象打开，后者将在循环结束后在垃圾回收时自动关闭。

你可以手动使用文件迭代器：它只是一个`__next__`方法（由内建函数`next`运行），与每次调用`readline`方法类似，只是`readline`方法在文件末尾（EOF）返回一个空字符串，而迭代器则抛出一个异常来结束迭代。

```python
>>> file = open('data.txt')
>>> 
>>> file.readline()
'1\n'
>>> file.readline()
'2\n'
>>> file.readline()
'3\n'
>>> file.readline()
'4\n'
>>> file.readline()
'5\n'
>>> file.readline()
'6\n'
>>> file.readline()
''
>>> 
>>> file.seek(0)
0
>>> file.__next__()
'1\n'
>>> file.__next__()
'2\n'
>>> file.__next__()
'3\n'
>>> file.__next__()
'4\n'
>>> file.__next__()
'5\n'
>>> file.__next__()
'6\n'
>>> file.__next__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> 
>>> file.seek(0)
0
>>> next(file)
'1\n'
>>> next(file)
'2\n'
>>> next(file)
'3\n'
>>> next(file)
'4\n'
>>> next(file)
'5\n'
>>> next(file)
'6\n'
>>> next(file)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

有趣的是，在所有迭代场景下，迭代器都自动得以调用，包括但不仅限于以下几种情况：

```python
>>> list(open('data.txt'))													# 强制逐行迭代
['1\n', '2\n', '3\n', '4\n', '5\n', '6\n']
>>> lines_list = [line_str.rstrip() for line_str in open('data.txt')]		# 解析
>>> lines_list
['1', '2', '3', '4', '5', '6']
>>> lines_list = [int(line_str) ** 2 for line_str in open('data.txt')]		# 任意操作
>>> lines_list
[1, 4, 9, 16, 25, 36]
>>> list(map(int, open('data.txt')))										# 应用函数
[1, 2, 3, 4, 5, 6]
>>> line = '3\n'
>>> line in open('data.txt')												# 判断文件是否含有该行
True
```

