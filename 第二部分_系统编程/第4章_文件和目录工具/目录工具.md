# 目录工具



## 遍历目录

### 用`os.popen`运行*shell*列表命令

在*Unix*下，我们通常在*shell*中键入`ls`来获取目录列表：

```python
beacherhou@alone-Vostro-14-5401:/media/beacherhou/Coding/code_obsidian_知识库/Python编程_Markdown笔记$ ls
第二部分_系统编程  jupyter  LICENSE  pp4e  PP4E-Examples-1.4  README.md
beacherhou@alone-Vostro-14-5401:/media/beacherhou/Coding/code_obsidian_知识库/Python编程_Markdown笔记$ ls -a
.  ..  第二部分_系统编程  .git  .gitignore  jupyter  LICENSE  pp4e  PP4E-Examples-1.4  README.md
```

脚本就可以在内部运行*shell*命令来获取文件和目录名称：

```python
# 使用readlines方法
>>> os.popen('ls').readlines()
['第二部分_系统编程\n', 'jupyter\n', 'LICENSE\n', 'pp4e\n', 'PP4E-Examples-1.4\n', 'README.md\n']

# 使用行迭代器
>>> for line_str in os.popen('ls'):
...     print(line_str[:-1])
... 
第二部分_系统编程
jupyter
LICENSE
pp4e
PP4E-Examples-1.4
README.md
>>> list(os.popen('ls'))
['第二部分_系统编程\n', 'jupyter\n', 'LICENSE\n', 'pp4e\n', 'PP4E-Examples-1.4\n', 'README.md\n']

# 使用列表解析
>>> [fn_str for fn_str in os.popen('ls')]
['第二部分_系统编程\n', 'jupyter\n', 'LICENSE\n', 'pp4e\n', 'PP4E-Examples-1.4\n', 'README.md\n']
```

如前所述，`os.popen`的缺点是可移植性差，且需启动一个独立进程，降低性能。