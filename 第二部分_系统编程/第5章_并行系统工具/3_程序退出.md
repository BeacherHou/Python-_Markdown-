# 程序退出



正常情况下*Python*脚本在程序末尾退出，我们也可以通过`sys`和`os`模块里的工具显示地调用程序退出。



## `sys`模块退出

`sys.exit(N)`抛出一个内建的`SystemExit`异常，并以状态N退出。

我们可以捕捉异常以拦截过早退出：

```python
>>> try:
...     sys.exit()
... except SystemExit:
...     print('ignoring exit')
... 
ignoring exit
```

事实上，用*Python*的`raise`语句显示地抛出内建`SystemExit`异常和调用`sys.exit()`效果是一样的。实践中更有用的是`try`代码块捕捉程序其他部分抛出的退出异常。

示例：test_exit_sys.py

```python
#!/usr/bin/env python
"测试sys.exit"

import sys


def later():
	print('Bye sys world')
	sys.exit(11)
	print('Never reached')


if __name__ == '__main__':
	later()
```

输出：test_exit_sys.py

```out
Bye sys world
```

载入`later`函数的程序可以将其退出异常捕获并重写，或者编写一个负责清理的`finally`代码块：

```python
>>> from test_exit_sys import later
>>> 
>>> try:
...     later()
... except SystemExit:
...     print('Ignoring...')
... 
Bye sys world
Ignoring...
>>> 
>>> try:
...     later()
... finally:
...     print('Clean up')
... 
Bye sys world
Clean up
beacherhou@alone-Vostro-14-5401:/media/beacherhou/Coding/code_obsidian_知识库/python-programming---markdown-notes/my_PP4E/system$  # 交互对话进程退出
```

