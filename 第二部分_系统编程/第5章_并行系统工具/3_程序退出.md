# 程序退出



正常情况下*Python*脚本在程序末尾退出，我们也可以通过`sys`和`os`模块里的工具显示地调用程序退出。



## `sys`模块退出

`sys.exit(N)`抛出一个内建的`SystemExit`异常，并以状态N退出。

我们可以捕捉异常以拦截过早退出：

```python
>>> try:
...     sys.exit()
... except SystemExit:
...     print('ignoring exit')
... 
ignoring exit
```

事实上，用*Python*的`raise`语句显示地抛出内建`SystemExit`异常和调用`sys.exit()`效果是一样的。实践中更有用的是`try`代码块捕捉程序其他部分抛出的退出异常。

示例：test_exit_sys.py

```python
#!/usr/bin/env python
"测试sys.exit"

import sys


def later():
	print('Bye sys world')
	sys.exit(11)
	print('Never reached')


if __name__ == '__main__':
	later()
```

输出：test_exit_sys.py

```out
Bye sys world
```

载入`later`函数的程序可以将其退出异常捕获并重写，或者编写一个负责清理的`finally`代码块：

```python
>>> from test_exit_sys import later
>>> 
>>> try:
...     later()
... except SystemExit:
...     print('Ignoring...')
... 
Bye sys world
Ignoring...
>>> 
>>> try:
...     later()
... finally:
...     print('Clean up')
... 
Bye sys world
Clean up
beacherhou@alone-Vostro-14-5401:/media/beacherhou/Coding/code_obsidian_知识库/python-programming---markdown-notes/my_PP4E/system$  # 交互对话进程退出
```



## `os`模块退出

在*Unix*下的分支进程中，我们通常调用`os_exit`函数退出。

对于`os_exit`，调用进程立即退出，而不是抛出可以捕获或忽略的异常。事实上，进程退出时也不输出流缓冲和运行清理处理器，所以这种做法一般应当只在分支出的子进程上进行，而最好不要用于整个程序的退出行为。

示例：test_exit_os.py

```python
#!/usr/bin/env python
"测试os._exit"

import os


def out_here():
	print('Bye os world')
	os._exit(11)
	print('Never reach')


if __name__ == '__main__':
	out_here()
```

输出：test_exit_os.py

```out
beacherhou@alone-Vostro-14-5401:/media/beacherhou/Coding/code_obsidian_知识库/python-programming---markdown-notes/my_PP4E/system$ ./test_exit_os.py 
Bye os world
```

**和`sys.exit`不同，`try`/`except`和`try`/`finally`对`os._exit`均不起作用。**



## *Shell*命令退出状态代码

`sys.exit`和`os._exit`都接受退出状态代码作为参数（在`sys`模块调用中为可选，但在`os`模块调用中为必需）。

在*Linux*下，我们询问`status`这个*shell*变量以获得上一个程序的退出状态，通常约定以非零的数值表示出现了某种问题：

```sh
beacherhou@alone-Vostro-14-5401:/media/beacherhou/Coding/code_obsidian_知识库/python-programming---markdown-notes/my_PP4E/system$ ./test_exit_sys.py 
Bye sys world
beacherhou@alone-Vostro-14-5401:/media/beacherhou/Coding/code_obsidian_知识库/python-programming---markdown-notes/my_PP4E/system$ echo $status
11
beacherhou@alone-Vostro-14-5401:/media/beacherhou/Coding/code_obsidian_知识库/python-programming---markdown-notes/my_PP4E/system$ ./test_exit_os.py 
Bye os world
beacherhou@alone-Vostro-14-5401:/media/beacherhou/Coding/code_obsidian_知识库/python-programming---markdown-notes/my_PP4E/system$ echo $status
11
```

在启动*Shell*命令时，可以这样提供退出状态：

- `os.system`调用的返回值
- `os.popen`对象的`close`方法的返回值（由于历史原因，如果退出状态是0则返回`None`）
- `subprocess`模块中的多种接口（如果`call`函数的返回值，`Popen`对象的`returncode`属性和`wait`方法的结果）

通过分支进程运行程序时，退出状态可在父进程中通过`os.wait`和`os.waitpid`调用获知。

