# 进程间通信



如果我们限制程序间可以通信的数据类型，下面这些简单的机制都可以理解为进程间通信的手段：

- 简单的文件。
- 命令行参数。
- 程序退出状态代码。
- *shell*环境变量。
- 标准流重定向。
- `os.popen`和`subprocess`提供的流管道。

举例来说，发送命令行选项和写入输入流可以让我们传入程序执行的参数；读取程序输出流和退出代码给我们提供了一个抓取结果的方法。因为派生程序继承了*shell*环境变量设置，所以后者又给我们提供了一个传入上下文环境的方法。而由`os.popen`或`subprocess`创建的管道允许更具动态的通信。

*Python*库中还有进程间通信（*IPC*）的其他工具，包括套接字、共享内存、信号、匿名和命名管道。

- 信号允许程序向其他程序发送简单的通知事件。
- 匿名管道允许共享文件描述符的线程及相关进程传递数据，但是一般来说依赖于类*Unix*下的分支进程模型，而后者不能跨平台移植。
- 命名管道则映射到系统的文件系统，它们允许完全不相关的程序进行交流，但并非所有平台的*Python*都提供此功能。
- 套接字映射到系统级别的端口号——它们不仅同样允许我们在同一台电脑上任意两个程序传递数据，而且还允许远程联网的机器上的程序之间通信，并且提供更具可移植性的选项。



## 匿名管道

管道是由操作系统实现的而非*Python*标准库。它是一个单向的通道，对于其两端来说接口类似一个文件。

管道由两种类型：

- 命名管道（*FIFO*）在你的计算机上有一个真实的外部文件代表。
- 匿名管道则仅在进程内部存在，通常作为父进程及其子进程通信的手段。

### 匿名管道的基本操作

`os.pipe`创建一个管道，该调用返回一个包含两个文件描述符的元组，这两个文件描述符代表这根管道的输入端和输出端。因为分支出来的子进程复制其父进程的文件描述符，所以在子进程中向管道输出描述符的写入可将数据发回管道的父进程，而这些管道在子进程派生之前就已经创建好了。

示例：pipe_1.py

```python
#!/usr/bin/env python
"用匿名管道从子进程向父进程发送数据"

import os
import time


def child(pipe_out_int):
	"子进程"
	sleep_int = 0
	while True:
		time.sleep(0.01)  # 防止向管道输出端发送的数据流重叠
		time.sleep(sleep_int)  # 模拟实际工作，让父进程等待
		msg_bytes = ('Spam {}'.format(sleep_int)).encode()  # 管道是二进制字节
		os.write(pipe_out_int, msg_bytes)  # 发送到父进程
		sleep_int += 1
		sleep_int %= 5  # 0到4，4到0


def main():
	pipe_in_int, pipe_out_int = os.pipe()  # 创建两个末端的管道

	if os.fork() == 0:  # 复制此进程
		child(pipe_out_int)  # 在副本中运行child()
	else:
		while True:
			msg_bytes = os.read(pipe_in_int, 32)  # 数据发送之前保持阻塞
			print('Parent {} got [{}] at {}'.format(
				os.getpid(), msg_bytes, time.time()
			))


if __name__ == '__main__':
	main()
```

输出：pipe_1.py

```out
Parent 9788 got [b'Spam 0'] at 1628658450.6990933
Parent 9788 got [b'Spam 1'] at 1628658451.710451
Parent 9788 got [b'Spam 2'] at 1628658453.7227986
Parent 9788 got [b'Spam 3'] at 1628658456.7358887
Parent 9788 got [b'Spam 4'] at 1628658460.7503185
Parent 9788 got [b'Spam 0'] at 1628658460.76058
Parent 9788 got [b'Spam 1'] at 1628658461.771917
Parent 9788 got [b'Spam 2'] at 1628658463.784269
Parent 9788 got [b'Spam 3'] at 1628658466.7971053
Parent 9788 got [b'Spam 4'] at 1628658470.8099616
Parent 9788 got [b'Spam 0'] at 1628658470.8200881
Parent 9788 got [b'Spam 1'] at 1628658471.8314338
Parent 9788 got [b'Spam 2'] at 1628658473.843869
...省略...
```

### 把管道描述符封装进文件对象

为了更好地区分这些消息（在某些平台上可能会混在一起），我们可以在管道中要求一个分割字符，比如换行符，因为我们可以用`os.fdopen`把管道描述符封装进一个文件对象，然后通过该文件对象的`readline`方法在管道内搜索下一个\\n分隔符。

示例：pipe_2.py

```python
#!/usr/bin/env python
"用匿名管道从子进程向父进程发送数据，并将管道描述符封装进文件对象"

import os
import time


def child(pipe_out_int):
	"子进程"
	sleep_int = 0
	while True:
		# time.sleep(0.01)  # 防止向管道输出端发送的数据流重叠
		time.sleep(sleep_int)  # 模拟实际工作，让父进程等待
		msg_bytes = ('Spam {}\n'.format(sleep_int)).encode()  # 管道是二进制字节
		os.write(pipe_out_int, msg_bytes)  # 发送到父进程
		sleep_int += 1
		sleep_int %= 5  # 0到4，4到0


def main():
	pipe_in_int, pipe_out_int = os.pipe()  # 创建两个末端的管道

	if os.fork() == 0:  # 复制此进程
		os.close(pipe_in_int)  # 在此关闭输入端
		child(pipe_out_int)  # 在副本中运行child()
	else:
		os.close(pipe_out_int)  # 在此关闭输出端
		pipe_in_fdfile = os.fdopen(pipe_in_int)  # 创建文本模式输入文件对象
		while True:
			msg_bytes = pipe_in_fdfile.readline()[:-1]  # 数据发送之前保持阻塞
			print('Parent {} got [{}] at {}'.format(
				os.getpid(), msg_bytes, time.time()
			))


if __name__ == '__main__':
	main()
```

输出：pipe_2.py

```out
Parent 12480 got [Spam 0] at 1628659738.422731
Parent 12480 got [Spam 1] at 1628659739.4239635
Parent 12480 got [Spam 2] at 1628659741.4260693
Parent 12480 got [Spam 3] at 1628659744.4292457
Parent 12480 got [Spam 4] at 1628659748.4317737
Parent 12480 got [Spam 0] at 1628659748.4318242
Parent 12480 got [Spam 1] at 1628659749.43286
Parent 12480 got [Spam 2] at 1628659751.434989
Parent 12480 got [Spam 3] at 1628659754.438162
Parent 12480 got [Spam 4] at 1628659758.4423606
Parent 12480 got [Spam 0] at 1628659758.4424183
Parent 12480 got [Spam 1] at 1628659759.443578
```

- 这个版本还在各个进程中关闭管道未使用的另一端，正常情况下就是这样。
- `os.fdopen`的默认r模式，读取操作返回一个文本数据*str*对象。

### 匿名管道和线程

示例：pipe_thread.py

```python
#!/usr/bin/env python
"匿名管道和线程而非进程，可在windows上工作"

import os
import time
import threading


def child(pipe_out_int):
	sleep_int = 0

	while True:
		time.sleep(0.01)
		time.sleep(sleep_int)
		msg_bytes = ('Spam {}'.format(sleep_int)).encode()
		os.write(pipe_out_int, msg_bytes)
		sleep_int += 1
		sleep_int %= 5


def parent(pipe_in_int):
	while True:
		msg_bytes = os.read(pipe_in_int, 32)
		print('Parent {} got [{}] at {}'.format(
			os.getpid(), msg_bytes, time.time()
		))


def main():
	pipe_in_int, pipe_out_int = os.pipe()
	threading.Thread(target=child, args=(pipe_out_int,)).start()
	parent(pipe_in_int)


if __name__ == '__main__':
	main()
```

输出：pipe_thread.py

```out
Parent 14472 got [b'Spam 0'] at 1628660580.0414195
Parent 14472 got [b'Spam 1'] at 1628660581.052756
Parent 14472 got [b'Spam 2'] at 1628660583.0650897
Parent 14472 got [b'Spam 3'] at 1628660586.0784411
Parent 14472 got [b'Spam 4'] at 1628660590.0928197
Parent 14472 got [b'Spam 0'] at 1628660590.1031415
Parent 14472 got [b'Spam 1'] at 1628660591.1144705
Parent 14472 got [b'Spam 2'] at 1628660593.1267684
Parent 14472 got [b'Spam 3'] at 1628660596.140166
Parent 14472 got [b'Spam 4'] at 1628660600.1516814
Parent 14472 got [b'Spam 0'] at 1628660600.1618528
Parent 14472 got [b'Spam 1'] at 1628660601.1731
```

### 用匿名管道进行双向*IPC*

用一个管道向程序发送请求，另一个向请求者发回答复。

示例：pipes.py

```python
#!/usr/bin/env python
"""
派生一个子进程/程序，连接到我的stdin/stdout和子进程的stdin/stdout，
我的读写映射到派生程序的输出和输入上；很像利用subprocess模块绑定流一样
"""

import os
import sys


def spawn(prog_str, *args_tuple):  # 传入程序名称，命令行参数
	
	# 获取流的描述符
	stdin_fd_int = sys.stdin.fileno()
	stdout_fd_int = sys.stdout.fileno()

	# 创建两个IPC管道，用于双向通信
	parent_in_fd_int, child_out_fd_int = os.pipe()
	child_in_fd_int, parent_out_fd_int = os.pipe()

	pid_int = os.fork()
	if pid_int:
		"父进程"

		# 在父进程中关闭子进程端
		os.close(child_in_fd_int)
		os.close(child_out_fd_int)

		# 复制流
		os.dup2(parent_in_fd_int, stdin_fd_int)
		os.dup2(parent_out_fd_int, stdout_fd_int)
	else:
		"子进程"

		# 在子进程中关闭父进程端
		os.close(parent_in_fd_int)
		os.close(parent_out_fd_int)

		# 将管道的输入和输出流
		os.dup2(child_in_fd_int, stdin_fd_int)
		os.dup2(child_out_fd_int, stdout_fd_int)

		args_tuple = (prog_str,) + args_tuple
		os.execvp(prog_str, args_tuple)  # 复制到子进程的程序
		assert False, "Execvp failed!"  # 如果execvp调用失败，则会中断子进程


def main():
	my_pid_int = os.getpid()
	spawn('python', 'pipes_test_child.py', 'spam')  # 分支子程序

	print('Hello 1 from parent', my_pid_int)  # 发送到子进程的stdin
	sys.stdout.flush()  # 清理stdout缓冲区
	reply_str = input()  # 发自子进程的stdout
	sys.stderr.write('Parent got: "{}"\n'.format(reply_str))

	print('Hello 2 from parent', my_pid_int)
	sys.stdout.flush()
	reply_str = sys.stdin.readline()
	sys.stderr.write('Parent got: "{}"\n'.format(reply_str[:-1]))


if __name__ == '__main__':
	main()
```

```sequence
parent_stdout-->parent_out: dup2
parent_out-->child_in: pipe
child_in-->child_stdin: dup2
```

```sequence
child_stdout-->child_out: dup2
child_out-->parent_in: pipe
parent_in-->parent_stdin:dup2
```

- os.dup2(fd1, fd2)：把文件描述符fd1命名的文件的所有相关系统信息复制到由fd2命名的文件中。

示例 ：pipes_test_child.py

```python
#!/usr/bin/env python
"pipes.py的测试子程序"

import os
import time
import sys


def main():
	my_pid_int = os.getpid()
	parent_pid_int = os.getppid()

	sys.stderr.write('Child {} of {} got arg: "{}"\n'.format(
		my_pid_int, parent_pid_int, sys.argv[1]
	))

	for i_int in range(2):
		time.sleep(3)
		reply = input()
		time.sleep(3)
		send_str = 'Child {} got: [{}]'.format(my_pid_int, reply)
		print(send_str)
		sys.stdout.flush()

if __name__ == '__main__':
	main()
```

输出：pipes.py

```out
Child 20267 of 20266 got arg: "spam"
Parent got: "Child 20267 got: [Hello 1 from parent 20266]"
Parent got: "Child 20267 got: [Hello 2 from parent 20266]"
```

### 再次探讨输出流缓冲：死锁和`flush`

如果将上述程序所有的`file.fulsh`语句注释掉，那么最后程序会困在一个死锁状态里，因为输出流会被缓冲保存起来，不会发送，因此两者都阻塞在输出调用上，程序永远不会继续运行。

有多种方法可以用来避免死锁：

- `flush`
- 参数
- `open`模式
- 命令管道
- 套接字
- 工具
