# 线程



线程和程序其他部分**并行地调用函数（或其他可调用的对象类型）**，所有线程均在**一个进程中运行**。线程经常用于**非阻塞的输出调用和GUI中长时间运行的任务**。线程还可作为表达成独立运行任务的算法的模型。

线程拥有多个优点：

- 性能改善
- 简单易用
- 共享全局内存
- 可移植性

线程也有三点缺陷：

- 线程运行程序里的函数
- 线程同步化和队列
- 全局解释器锁（*DIL*）



## `_thread`模块

### 基本用法

示例：thread_1.py

```python
#!/usr/bin/env python
"派生出子线程，直到输入“q”"


import _thread


def child(tid_int):
	"子线程"
	print('Hello from child!', tid_int)


def parent():
	"父线程"
	tid_int = 0
	while True:
		_thread.start_new_thread(child, (tid_int,))
		if input() == 'q':
			break
		tid_int += 1


if __name__ == '__main__':
	parent()
```

输出：thread_1.py

```out
Hello from child! 0

Hello from child! 1

Hello from child! 2
q
```

- 关于线程的代码只有两行：载入`_thread`模块和创建线程的调用。
- `_thread.start_new_thread`函数用于开始一个新线程。它接受一个函数对象（或其他可调用对象）和一个参数元组。它本身返回一个没有用的值，它派生出来的线程在运行的函数返回后安静地退出。此外，如果线程中的函数抛出未获捕捉的异常，则将打印出堆栈跟踪记录并退出线程，但**程序的其他部分仍将运行**。

### 用`_thread`编写线程的其他方法

线程也可以运行`lambda`函数或者某个对象的绑定方法（或其他可调用对象）：

示例：thread_alt.py

```python
#!/usr/bin/env python
"所有三个线程均打印“4294967296”"

import _thread
import time


def power(a_int):
	"打印a_int的32次方"
	print(a_int ** 32)


class Power:
	"次方"
	def __init__(self, a_int):
		self.a_int = a_int

	def act(self):
		"打印a_int的32次方"
		print(self.a_int ** 32)


def main():
	# 简单函数
	_thread.start_new_thread(power, (2,))
	# 待执行的lambda函数
	_thread.start_new_thread(lambda: power(2), ())
	# 绑定方法对象
	obj_Power = Power(2)
	_thread.start_new_thread(obj_Power.act, ())
	time.sleep(0.01)	# 防止主线程较早退出


if __name__ == '__main__':
	main()
```

### 运行多个线程

示例：thread_count.py

```python
#!/usr/bin/env python
"五个数数的线程"

import _thread
import time


def counter(id_int, count_int):
	"从0数到count_int"
	for i_int in range(count_int + 1):
		print('[{}] -> {}'.format(id_int, i_int))
		time.sleep(1)


def main():
	for i_int in range(5):
		_thread.start_new_thread(counter, (i_int,5))
	time.sleep(7)


if __name__ == '__main__':
	main()
```

输出：thread_count.py

```out
[1] -> 0
[0] -> 0
[2] -> 0
[4] -> 0
[3] -> 0
[1] -> 1
[4] -> 1[2] -> 1
[3] -> 1
[0] -> 1
[1] -> 2
[4] -> 2
[3] -> 2
[2] -> 2
[0] -> 2[1] -> 3
[4] -> 3
[2] -> 3[0] -> 3
[3] -> 3
[1] -> 4
[4] -> 4
[3] -> 4
[0] -> 4[2] -> 4
[1] -> 5
[4] -> 5
[3] -> 5
[0] -> 5
[2] -> 5
```

- 输出之所以看起来很不整齐，是因为所有线程共享一个`stdout`，会导致随机混杂。

### 同步访问共享对象和名称

**在线程生命期间一直持续存在的进程中，对象和命名空间在所有派生线程间共享**。因此我们需时刻小心，**避免数个线程同时改变全局对象和名称（结果就是会丢失某个改变或把共享对象的状态完全损坏）**。

`_thread`模块提供了相关工具，这些工具基于锁的概念：想要修改一个全局对象，线程需要获得一把锁，然后进行修改，之后释放这把锁，后者再为其他线程所获取。*Python*确保任何时间点只有一个线程持有锁；如果在持有期间其他线程请求获得锁，那么这些请求将被一直阻塞，直到释放出锁。锁对象的分配和处理由自由且可跨平台移植的`_thread`模块中的调用执行，后者自动映射到底层操作平台的线程锁定机制。

示例：thread_count_mutex.py

```python
#!/usr/bin/env python
"五个数数的线程，并同步化对stdout的访问"

import _thread
import time

MUTEX = _thread.allocate_lock()  # 创建全局锁对象


def counter(id_int, count_int):
	"从0数到count_int"
	for i_int in range(count_int + 1):
		MUTEX.acquire()  # 获取全局锁
		print('[{}] -> {}'.format(id_int, i_int))
		MUTEX.release()  # 释放全局锁
		time.sleep(1)


def main():
	for i_id_int in range(5):
		_thread.start_new_thread(counter, (i_id_int, 5))
	time.sleep(7)
	print('Main thread exiting ...')


if __name__ == '__main__':
	main()
```

输出：thread_count_mutex.py

```out
[0] -> 0
[2] -> 0
[3] -> 0
[4] -> 0
[1] -> 0
[0] -> 1
[2] -> 1
[3] -> 1
[4] -> 1
[1] -> 1
[2] -> 2
[0] -> 2
[3] -> 2
[4] -> 2
[1] -> 2
[2] -> 3
[0] -> 3
[3] -> 3
[4] -> 3
[1] -> 3
[2] -> 4
[0] -> 4
[3] -> 4
[1] -> 4
[4] -> 4
[0] -> 5
[3] -> 5
[2] -> 5
[1] -> 5
[4] -> 5
Main thread exiting ...
```

